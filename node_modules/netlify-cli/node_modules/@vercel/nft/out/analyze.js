"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const rollup_pluginutils_1 = require("rollup-pluginutils");
const static_eval_1 = require("./utils/static-eval");
const acorn_1 = require("acorn");
const bindings_1 = __importDefault(require("bindings"));
const ast_helpers_1 = require("./utils/ast-helpers");
const glob_1 = __importDefault(require("glob"));
const get_package_base_1 = require("./utils/get-package-base");
const binary_locators_1 = require("./utils/binary-locators");
const interop_require_1 = require("./utils/interop-require");
const special_cases_1 = __importDefault(require("./utils/special-cases"));
const resolve_dependency_js_1 = __importDefault(require("./resolve-dependency.js"));
//@ts-ignore
const node_gyp_build_1 = __importDefault(require("node-gyp-build"));
//@ts-ignore
const node_pre_gyp_1 = __importDefault(require("@mapbox/node-pre-gyp"));
const url_1 = require("url");
// TypeScript fails to resolve estree-walker to the top due to the conflicting
// estree-walker version in rollup-pluginutils so we use require here instead
const asyncWalk = require('estree-walker').asyncWalk;
// Note: these should be deprecated over time as they ship in Acorn core
const acorn = acorn_1.Parser.extend(
//require("acorn-class-fields"),
//require("acorn-static-class-features"),
//require("acorn-private-class-elements")
);
const os_1 = __importDefault(require("os"));
const wrappers_1 = require("./utils/wrappers");
const resolve_from_1 = __importDefault(require("resolve-from"));
const staticProcess = {
    cwd: () => {
        return cwd;
    },
    env: {
        NODE_ENV: static_eval_1.UNKNOWN,
        [static_eval_1.UNKNOWN]: true
    },
    [static_eval_1.UNKNOWN]: true
};
// unique symbol value to identify express instance in static analysis
const EXPRESS_SET = Symbol();
const EXPRESS_ENGINE = Symbol();
const NBIND_INIT = Symbol();
const SET_ROOT_DIR = Symbol();
const PKG_INFO = Symbol();
const FS_FN = Symbol();
const FS_DIR_FN = Symbol();
const BINDINGS = Symbol();
const NODE_GYP_BUILD = Symbol();
const fsSymbols = {
    access: FS_FN,
    accessSync: FS_FN,
    createReadStream: FS_FN,
    exists: FS_FN,
    existsSync: FS_FN,
    fstat: FS_FN,
    fstatSync: FS_FN,
    lstat: FS_FN,
    lstatSync: FS_FN,
    open: FS_FN,
    readdir: FS_DIR_FN,
    readdirSync: FS_DIR_FN,
    readFile: FS_FN,
    readFileSync: FS_FN,
    stat: FS_FN,
    statSync: FS_FN
};
const fsExtraSymbols = Object.assign(Object.assign({}, fsSymbols), { pathExists: FS_FN, pathExistsSync: FS_FN, readJson: FS_FN, readJSON: FS_FN, readJsonSync: FS_FN, readJSONSync: FS_FN });
const staticModules = Object.assign(Object.create(null), {
    bindings: {
        default: BINDINGS
    },
    express: {
        default: function () {
            return {
                [static_eval_1.UNKNOWN]: true,
                set: EXPRESS_SET,
                engine: EXPRESS_ENGINE
            };
        }
    },
    fs: Object.assign({ default: fsSymbols }, fsSymbols),
    'fs-extra': Object.assign({ default: fsExtraSymbols }, fsExtraSymbols),
    'graceful-fs': Object.assign({ default: fsSymbols }, fsSymbols),
    process: Object.assign({ default: staticProcess }, staticProcess),
    // populated below
    path: {
        default: {}
    },
    os: Object.assign({ default: os_1.default }, os_1.default),
    '@mapbox/node-pre-gyp': Object.assign({ default: node_pre_gyp_1.default }, node_pre_gyp_1.default),
    'node-pre-gyp': binary_locators_1.pregyp,
    'node-pre-gyp/lib/pre-binding': binary_locators_1.pregyp,
    'node-pre-gyp/lib/pre-binding.js': binary_locators_1.pregyp,
    'node-gyp-build': {
        default: NODE_GYP_BUILD
    },
    'nbind': {
        init: NBIND_INIT,
        default: {
            init: NBIND_INIT
        }
    },
    'resolve-from': {
        default: resolve_from_1.default
    },
    'strong-globalize': {
        default: {
            SetRootDir: SET_ROOT_DIR
        },
        SetRootDir: SET_ROOT_DIR
    },
    'pkginfo': {
        default: PKG_INFO
    }
});
const globalBindings = {
    // Support for require calls generated from `import` statements by babel
    _interopRequireDefault: interop_require_1.normalizeDefaultRequire,
    _interopRequireWildcard: interop_require_1.normalizeWildcardRequire,
    // Support for require calls generated from `import` statements by tsc
    __importDefault: interop_require_1.normalizeDefaultRequire,
    __importStar: interop_require_1.normalizeWildcardRequire,
    MONGOOSE_DRIVER_PATH: undefined,
    URL: url_1.URL,
    Object: {
        assign: Object.assign
    }
};
globalBindings.global = globalBindings.GLOBAL = globalBindings.globalThis = globalBindings;
// call expression triggers
const TRIGGER = Symbol();
binary_locators_1.pregyp.find[TRIGGER] = true;
const staticPath = staticModules.path;
Object.keys(path_1.default).forEach(name => {
    const pathFn = path_1.default[name];
    if (typeof pathFn === 'function') {
        const fn = function mockPath() {
            return pathFn.apply(mockPath, arguments);
        };
        fn[TRIGGER] = true;
        staticPath[name] = staticPath.default[name] = fn;
    }
    else {
        staticPath[name] = staticPath.default[name] = pathFn;
    }
});
// overload path.resolve to support custom cwd
staticPath.resolve = staticPath.default.resolve = function (...args) {
    return path_1.default.resolve.apply(this, [cwd, ...args]);
};
staticPath.resolve[TRIGGER] = true;
const excludeAssetExtensions = new Set(['.h', '.cmake', '.c', '.cpp']);
const excludeAssetFiles = new Set(['CHANGELOG.md', 'README.md', 'readme.md', 'changelog.md']);
let cwd;
const absoluteRegEx = /^\/[^\/]+|^[a-z]:[\\/][^\\/]+/i;
function isAbsolutePathOrUrl(str) {
    if (str instanceof url_1.URL)
        return str.protocol === 'file:';
    if (typeof str === 'string') {
        if (str.startsWith('file:')) {
            try {
                new url_1.URL(str);
                return true;
            }
            catch (_a) {
                return false;
            }
        }
        return absoluteRegEx.test(str);
    }
    return false;
}
const BOUND_REQUIRE = Symbol();
const repeatGlobRegEx = /([\/\\]\*\*[\/\\]\*)+/g;
;
async function analyze(id, code, job) {
    const assets = new Set();
    const deps = new Set();
    const imports = new Set();
    const dir = path_1.default.dirname(id);
    // if (typeof options.production === 'boolean' && staticProcess.env.NODE_ENV === UNKNOWN)
    //  staticProcess.env.NODE_ENV = options.production ? 'production' : 'dev';
    cwd = job.cwd;
    const pkgBase = get_package_base_1.getPackageBase(id);
    const emitAssetDirectory = (wildcardPath) => {
        if (!job.analysis.emitGlobs)
            return;
        const wildcardIndex = wildcardPath.indexOf(static_eval_1.WILDCARD);
        const dirIndex = wildcardIndex === -1 ? wildcardPath.length : wildcardPath.lastIndexOf(path_1.default.sep, wildcardIndex);
        const assetDirPath = wildcardPath.substring(0, dirIndex);
        const patternPath = wildcardPath.slice(dirIndex);
        const wildcardPattern = patternPath.replace(static_eval_1.wildcardRegEx, (_match, index) => {
            return patternPath[index - 1] === path_1.default.sep ? '**/*' : '*';
        }).replace(repeatGlobRegEx, '/**/*') || '/**/*';
        if (job.ignoreFn(path_1.default.relative(job.base, assetDirPath + wildcardPattern)))
            return;
        assetEmissionPromises = assetEmissionPromises.then(async () => {
            if (job.log)
                console.log('Globbing ' + assetDirPath + wildcardPattern);
            const files = (await new Promise((resolve, reject) => glob_1.default(assetDirPath + wildcardPattern, { mark: true, ignore: assetDirPath + '/**/node_modules/**/*' }, (err, files) => err ? reject(err) : resolve(files))));
            files
                .filter(name => !excludeAssetExtensions.has(path_1.default.extname(name)) &&
                !excludeAssetFiles.has(path_1.default.basename(name)) &&
                !name.endsWith('/'))
                .forEach(file => assets.add(file));
        });
    };
    let assetEmissionPromises = Promise.resolve();
    // remove shebang
    code = code.replace(/^#![^\n\r]*[\r\n]/, '');
    let ast;
    let isESM = false;
    try {
        ast = acorn.parse(code, { ecmaVersion: 'latest', allowReturnOutsideFunction: true });
        isESM = false;
    }
    catch (e) {
        const isModule = e && e.message && e.message.includes('sourceType: module');
        if (!isModule) {
            job.warnings.add(new Error(`Failed to parse ${id} as script:\n${e && e.message}`));
        }
    }
    //@ts-ignore
    if (!ast) {
        try {
            ast = acorn.parse(code, { ecmaVersion: 'latest', sourceType: 'module', allowAwaitOutsideFunction: true });
            isESM = true;
        }
        catch (e) {
            job.warnings.add(new Error(`Failed to parse ${id} as module:\n${e && e.message}`));
            // Parser errors just skip analysis
            return { assets, deps, imports, isESM: false };
        }
    }
    const importMetaUrl = url_1.pathToFileURL(id).href;
    const knownBindings = Object.assign(Object.create(null), {
        __dirname: {
            shadowDepth: 0,
            value: { value: path_1.default.resolve(id, '..') }
        },
        __filename: {
            shadowDepth: 0,
            value: { value: id }
        },
        process: {
            shadowDepth: 0,
            value: { value: staticProcess }
        }
    });
    if (!isESM || job.mixedModules) {
        knownBindings.require = {
            shadowDepth: 0,
            value: {
                value: {
                    [static_eval_1.FUNCTION](specifier) {
                        deps.add(specifier);
                        const m = staticModules[specifier.startsWith('node:') ? specifier.slice(5) : specifier];
                        return m.default;
                    },
                    resolve(specifier) {
                        return resolve_dependency_js_1.default(specifier, id, job);
                    }
                }
            }
        };
        knownBindings.require.value.value.resolve[TRIGGER] = true;
    }
    function setKnownBinding(name, value) {
        // require is somewhat special in that we shadow it but don't
        // statically analyze it ("known unknown" of sorts)
        if (name === 'require')
            return;
        knownBindings[name] = {
            shadowDepth: 0,
            value: value
        };
    }
    function getKnownBinding(name) {
        const binding = knownBindings[name];
        if (binding) {
            if (binding.shadowDepth === 0) {
                return binding.value;
            }
        }
        return undefined;
    }
    function hasKnownBindingValue(name) {
        const binding = knownBindings[name];
        return binding && binding.shadowDepth === 0;
    }
    if ((isESM || job.mixedModules) && isAst(ast)) {
        for (const decl of ast.body) {
            if (decl.type === 'ImportDeclaration') {
                const source = String(decl.source.value);
                deps.add(source);
                const staticModule = staticModules[source.startsWith('node:') ? source.slice(5) : source];
                if (staticModule) {
                    for (const impt of decl.specifiers) {
                        if (impt.type === 'ImportNamespaceSpecifier')
                            setKnownBinding(impt.local.name, { value: staticModule });
                        else if (impt.type === 'ImportDefaultSpecifier' && 'default' in staticModule)
                            setKnownBinding(impt.local.name, { value: staticModule.default });
                        else if (impt.type === 'ImportSpecifier' && impt.imported.name in staticModule)
                            setKnownBinding(impt.local.name, { value: staticModule[impt.imported.name] });
                    }
                }
            }
            else if (decl.type === 'ExportNamedDeclaration' || decl.type === 'ExportAllDeclaration') {
                if (decl.source)
                    deps.add(String(decl.source.value));
            }
        }
    }
    async function computePureStaticValue(expr, computeBranches = true) {
        const vars = Object.create(null);
        Object.keys(globalBindings).forEach(name => {
            vars[name] = { value: globalBindings[name] };
        });
        Object.keys(knownBindings).forEach(name => {
            vars[name] = getKnownBinding(name);
        });
        vars['import.meta'] = { url: importMetaUrl };
        // evaluate returns undefined for non-statically-analyzable
        const result = await static_eval_1.evaluate(expr, vars, computeBranches);
        return result;
    }
    // statically determinable leaves are tracked, and inlined when the
    // greatest parent statically known leaf computation corresponds to an asset path
    let staticChildNode;
    let staticChildValue;
    // Express engine opt-out
    let definedExpressEngines = false;
    function emitWildcardRequire(wildcardRequire) {
        if (!job.analysis.emitGlobs || !wildcardRequire.startsWith('./') && !wildcardRequire.startsWith('../'))
            return;
        wildcardRequire = path_1.default.resolve(dir, wildcardRequire);
        const wildcardIndex = wildcardRequire.indexOf(static_eval_1.WILDCARD);
        const dirIndex = wildcardIndex === -1 ? wildcardRequire.length : wildcardRequire.lastIndexOf(path_1.default.sep, wildcardIndex);
        const wildcardDirPath = wildcardRequire.substring(0, dirIndex)